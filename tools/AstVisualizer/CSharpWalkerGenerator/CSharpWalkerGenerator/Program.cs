using System;

namespace GenerateCSharpWalker
{
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Reflection;
    using System.Text;
    using System.Xml.Linq;


    class Program
    {
        private static Type visitorDefinition = typeof(CSharpSyntaxVisitor);
        private static Type csharpExtensionsDefinition = typeof(Microsoft.CodeAnalysis.CSharp.CSharpExtensions);

        private static bool IsA(string typeName, Type baseType)
        {
            var assembly = typeof(CSharpSyntaxNode).Assembly;
            Type t = assembly.GetType("Microsoft.CodeAnalysis.CSharp.Syntax." + typeName, false);
            if (t != null)
                return t == baseType || t.IsSubclassOf(baseType);

            return false;
        }

        private static bool HasGetDeclaredSymbolMethod(string typeName)
        {
            var csharpExtensionsDefinitionMethods = csharpExtensionsDefinition.GetMethods(BindingFlags.Static | BindingFlags.Public);
            var getDeclaredSymbolDefinitions = csharpExtensionsDefinitionMethods.Where(m => m.Name == "GetDeclaredSymbol");
            foreach (var definition in getDeclaredSymbolDefinitions)
            {
                var secondParmType = definition.GetParameters()[1].ParameterType;
                if (IsA(typeName, secondParmType))
                    return true;
            }
            return false;
        }

        private static void WriteToFile(StringBuilder builder, string fileName)
        {
            File.WriteAllText(fileName, builder.ToString());
        }

        static void Main(string[] args)
        {
            var builder = new System.Text.StringBuilder();

            // Single quotes are used here to make the listing legible. They are replaced below.
            builder.AppendLine(@"// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSharpExtractor
{
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using System.Xml.Linq;

    /// <summary>
    /// This class can be used if it is required to do traversal where individual notes are processed. 
    /// It also has a general Visit node method. First the VisitNode method is called, 
    /// and then the more specialized Visit* method is called.
    /// 
    /// The visit methods below were generated by traversing the CSharpSyntaxWalker methods using reflection.
    /// It is not practical to hand write all these methods by hand.
    /// If a version is required for VB.NET (or as new versions of C# see the light of day), the same approach 
    /// can be followed to automatically generate the methods. This will result in a syntax-only tree being 
    /// extracted - The methods will then need to be modified in some cases to include the model information.
    /// If required, the generator (that walks the methods of the CSharpSyntaxVisitor) can be made more intelligent,
    /// by knowing which nodes have auxiliary information (like type information) by also knowing about the 
    /// extension methods in Microsoft.CodeAnalysis.CSharp.CSharpExtensions). In this way, the extractor methods 
    /// can be generated with fidelity.
    /// </summary>
    class CSharpConceptWalker : CSharpSyntaxWalker
    {
        // Generating from FW
        private readonly XDocument document;
        private readonly CSharpCompilation compilation;
        private readonly SemanticModel semanticModel;
        private SymbolDisplayFormat symbolDisplayFormat;
        private readonly IDictionary<string, string> classBaseList = new Dictionary<string, string>();

        /// <summary>
        /// Indicates whether or not the source should be included in the node defining classes and 
        /// other top level compilation units. This should really be fetched from a settings file or
        /// an environment variable.
        /// </summary>
        private bool IncludeSource {  get { return true; } }

        /// <summary>
        /// This is the stack of XML elements built during extraction. This is needed because there
        /// is no payload information that can be passed to each visit* method
        /// </summary>
        private Stack<XElement> stack = new Stack<XElement>();

        public XDocument Document { get { return this.document;  } }

        protected string GetFullMetadataName(ISymbol s) 
        {
            if (s == null || IsRootNamespace(s))
            {
                return string.Empty;
            }

            if (s is ILocalSymbol ls)
            {
                return ls.ContainingSymbol.ToString() + '.' + s.Name;
            }

            return s.ToString();        
        }

        private static bool IsRootNamespace(ISymbol symbol) 
        {
            INamespaceSymbol s = null;
            return ((s = symbol as INamespaceSymbol) != null) && s.IsGlobalNamespace;
        }

        private void AddLocationAttributes(XElement element, SyntaxNode node)
        {
            this.AddCommentAttribute(node, element);
            element.Add(new XAttribute('StartLine', node.GetLocation().GetLineSpan().StartLinePosition.Line+1));
            element.Add(new XAttribute('StartCol', node.GetLocation().GetLineSpan().StartLinePosition.Character + 1));
            element.Add(new XAttribute('EndLine', node.GetLocation().GetLineSpan().EndLinePosition.Line + 1));
            element.Add(new XAttribute('EndCol', node.GetLocation().GetLineSpan().EndLinePosition.Character + 1));
        }

        private void AddTypeAttribute(XElement element, ExpressionSyntax node)
        {
            TypeInfo expressionType = this.semanticModel.GetTypeInfo(node);
            var type = TypeName(expressionType.Type);
            if (!string.IsNullOrEmpty(type))
            {
                element.Add(new XAttribute('ExpressionType', type));
            }
        }

        private void AddCommentAttribute(SyntaxNode node, XElement element)
        {
            var triviaString = node.GetLeadingTrivia().ToString();
            if (triviaString.Contains('//') || triviaString.Contains('/*'))
                element.Add(new XAttribute('Comment', triviaString));
        }

        #region Symbol Information
        private void AddSymbolInformation(XElement element, ISymbol symbol, string prefix = '')
        {
            if (prefix.Length > 0)
            {
                prefix += '.';
            }

            if (symbol != null)
            {
                element.Add(new XAttribute(prefix + nameof(symbol.Name), symbol.Name));
                element.Add(new XAttribute(prefix + 'FQN', GetFullMetadataName(symbol)));

                if (symbol.DeclaredAccessibility != Accessibility.NotApplicable)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.DeclaredAccessibility), symbol.DeclaredAccessibility));
                }

                element.Add(new XAttribute(prefix + nameof(symbol.IsStatic), symbol.IsStatic));
                element.Add(new XAttribute(prefix + nameof(symbol.IsAbstract), symbol.IsAbstract));
                element.Add(new XAttribute(prefix + nameof(symbol.IsOverride), symbol.IsOverride));
                element.Add(new XAttribute(prefix + nameof(symbol.IsVirtual), symbol.IsVirtual));
                element.Add(new XAttribute(prefix + nameof(symbol.IsSealed), symbol.IsSealed));
                element.Add(new XAttribute(prefix + nameof(symbol.IsImplicitlyDeclared), symbol.IsImplicitlyDeclared));
                element.Add(new XAttribute(prefix + nameof(symbol.IsExtern), symbol.IsExtern));
                element.Add(new XAttribute(prefix + nameof(symbol.IsDefinition), symbol.IsDefinition));
                element.Add(new XAttribute(prefix + nameof(symbol.Language), symbol.Language));
                element.Add(new XAttribute(prefix + nameof(symbol.Kind), symbol.Kind));

                if (symbol.ContainingType != null)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.ContainingType), symbol.ContainingType.Name));
                }

                if (symbol.ContainingAssembly != null)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.ContainingAssembly), symbol.ContainingAssembly.Identity.GetDisplayName()));
                }
            }
        }

        private void AddSymbolInformation(XElement element, ILabelSymbol symbol)
        {
            if (symbol != null)
            {
                this.AddSymbolInformation(element, (ISymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, ITypeSymbol symbol, string prefix = '')
        {
            if (symbol != null)
            {
                if (prefix.Length > 0)
                {
                    prefix = prefix + '.';
                }

                element.Add(new XAttribute(prefix + 'Type', TypeName(symbol)));
                
                if (symbol.BaseType != null)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.BaseType), TypeName(symbol.BaseType)));
                }
                
                element.Add(new XAttribute(prefix + nameof(symbol.IsReadOnly), symbol.IsReadOnly));
                element.Add(new XAttribute(prefix + nameof(symbol.IsRefLikeType), symbol.IsRefLikeType));
                element.Add(new XAttribute(prefix + nameof(symbol.SpecialType), symbol.SpecialType));
                element.Add(new XAttribute(prefix + nameof(symbol.IsTupleType), symbol.IsTupleType));
                element.Add(new XAttribute(prefix + nameof(symbol.IsAnonymousType), symbol.IsAnonymousType));
                element.Add(new XAttribute(prefix + nameof(symbol.IsValueType), symbol.IsValueType));
                element.Add(new XAttribute(prefix + nameof(symbol.IsReferenceType), symbol.IsReferenceType));

                this.AddSymbolInformation(element, (ISymbol)symbol, prefix);
            }
        }

        private void AddSymbolInformation(XElement element, ILocalSymbol symbol, string prefix = '')
        {
            if (symbol != null)
            {
                if (prefix.Length > 0)
                {
                    prefix = prefix + '.';
                }

                element.Add(new XAttribute(prefix + nameof(symbol.NullableAnnotation), symbol.NullableAnnotation));
                element.Add(new XAttribute(prefix + nameof(symbol.IsConst), symbol.IsConst));
                element.Add(new XAttribute(prefix + nameof(symbol.IsRef), symbol.IsRef));
                element.Add(new XAttribute(prefix + nameof(symbol.RefKind), symbol.RefKind));
                element.Add(new XAttribute(prefix + nameof(symbol.HasConstantValue), symbol.HasConstantValue));
                if (symbol.ConstantValue != null)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.ConstantValue), symbol.ConstantValue));

                }
                element.Add(new XAttribute(prefix + nameof(symbol.IsFixed), symbol.IsFixed));

                var type = GetFullMetadataName(symbol.Type);
                if (!string.IsNullOrEmpty(type))
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.Type), type));
                }
                this.AddSymbolInformation(element, (ISymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, INamedTypeSymbol symbol)
        {
            if (symbol != null)
            {
                element.Add(new XAttribute(nameof(symbol.IsUnboundGenericType), symbol.IsUnboundGenericType));
                element.Add(new XAttribute(nameof(symbol.IsGenericType), symbol.IsGenericType));
                element.Add(new XAttribute(nameof(symbol.Arity), symbol.Arity));

                this.AddSymbolInformation(element, (ITypeSymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, IAliasSymbol symbol)
        {
            if (symbol != null)
            {
                AddSymbolInformation(element, (ISymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, ITypeParameterSymbol symbol)
        {
            if (symbol != null)
            {
                AddSymbolInformation(element, (ITypeSymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, IPropertySymbol symbol)
        {
            if (symbol != null)
            {
                element.Add(new XAttribute(nameof(symbol.IsReadOnly), symbol.IsReadOnly));
                element.Add(new XAttribute(nameof(symbol.IsIndexer), symbol.IsIndexer));
                element.Add(new XAttribute(nameof(symbol.ReturnsByRefReadonly), symbol.ReturnsByRefReadonly));
                element.Add(new XAttribute(nameof(symbol.ReturnsByRef), symbol.ReturnsByRef));
                element.Add(new XAttribute(nameof(symbol.IsWithEvents), symbol.IsWithEvents));
                element.Add(new XAttribute(nameof(symbol.IsWriteOnly), symbol.IsWriteOnly));
                element.Add(new XAttribute(nameof(symbol.RefKind), symbol.RefKind));
                element.Add(new XAttribute(nameof(symbol.Type), GetFullMetadataName(symbol.Type)));

                if (symbol.GetMethod != null)
                {
                    this.AddSymbolInformation(element, symbol.GetMethod, 'Getter');
                }

                if (symbol.SetMethod != null)
                {
                    this.AddSymbolInformation(element, symbol.SetMethod, 'Setter');
                }
            }
        }

        private void AddSymbolInformation(XElement element, IMethodSymbol symbol, string prefix = '')
        {
            if (symbol != null)
            {
                if (prefix.Length > 0)
                {
                    prefix += '.';
                }

                element.Add(new XAttribute(prefix + nameof(symbol.Arity), symbol.Arity));
                element.Add(new XAttribute(prefix + nameof(symbol.ReturnType), GetFullMetadataName(symbol.ReturnType)));
                element.Add(new XAttribute(prefix + nameof(symbol.IsReadOnly), symbol.IsReadOnly));
                element.Add(new XAttribute(prefix + nameof(symbol.IsConditional), symbol.IsConditional));
                element.Add(new XAttribute(prefix + nameof(symbol.IsExtensionMethod), symbol.IsExtensionMethod));
                element.Add(new XAttribute(prefix + nameof(symbol.IsAsync), symbol.IsAsync));
                element.Add(new XAttribute(prefix + nameof(symbol.IsGenericMethod), symbol.IsGenericMethod));
                element.Add(new XAttribute(prefix + nameof(symbol.IsCheckedBuiltin), symbol.IsCheckedBuiltin));
                element.Add(new XAttribute(prefix + nameof(symbol.HidesBaseMethodsByName), symbol.HidesBaseMethodsByName));
                element.Add(new XAttribute(prefix + nameof(symbol.ReturnsVoid), symbol.ReturnsVoid));
                element.Add(new XAttribute(prefix + nameof(symbol.ReturnsByRef), symbol.ReturnsByRef));
                element.Add(new XAttribute(prefix + nameof(symbol.ReturnsByRefReadonly), symbol.ReturnsByRefReadonly));
                element.Add(new XAttribute(prefix + nameof(symbol.MethodKind), symbol.MethodKind));
                element.Add(new XAttribute(prefix + nameof(symbol.RefKind), symbol.RefKind));

                if (symbol.OverriddenMethod != null)
                {
                    element.Add(new XAttribute(prefix + nameof(symbol.OverriddenMethod), symbol.OverriddenMethod.Name));
                    element.Add(new XAttribute(prefix + 'OverriddenMethodType', symbol.OverriddenMethod.ContainingSymbol.ToString()));
                }

                this.AddSymbolInformation(element, (ISymbol)symbol);
            }
        }

        private void AddSymbolInformation(XElement element, IRangeVariableSymbol symbol)
        {
        }

        #endregion

        private static string ElementName(SyntaxNode node)
        {
            return node.Kind().ToString();
        }

        private static XElement CreateElement(SyntaxNode node)
        {
            string nodeKind = ElementName(node);
            return new XElement(nodeKind);
        }

        private string TypeName(ITypeSymbol typeSymbol)
        {
            return typeSymbol?.ToDisplayString(this.symbolDisplayFormat) ?? string.Empty;
        }

        /// <summary>
        /// Creates an instance of the Concept walker for a compilationunit in the compilation
        /// </summary>
        /// <param name='compilation'>The compilation under which this compilationunit is compiled.</param>
        /// <param name='tree'>The compilation unit</param>
        public CSharpConceptWalker(CSharpCompilation compilation, SyntaxTree tree, XDocument compilationDocument)
        {
            this.compilation = compilation;
            this.semanticModel = compilation.GetSemanticModel(tree);

            this.symbolDisplayFormat = new SymbolDisplayFormat(
                miscellaneousOptions: SymbolDisplayMiscellaneousOptions.None,
                typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);

            this.document = compilationDocument;
            stack.Push(compilationDocument.Root);
        }
".Replace('\'', '"'));

            // Traverse all the overridable visit* methods
            foreach (var visitMethod in visitorDefinition.GetMethods(BindingFlags.Public | BindingFlags.Instance)
                .Where(m => m.Name.StartsWith("Visit")))
            {
                if (visitMethod.Name.Length == 5)
                {
                    // The Visit(SyntacNode) method should not be generated
                    continue;
                }

                Console.WriteLine(visitMethod.Name);
                var parameterType = visitMethod.GetParameters()[0].ParameterType.Name;

                builder.AppendLine($"    public override void {visitMethod.Name}({parameterType} node)");
                builder.AppendLine("    {");
                builder.AppendLine("        var element = CreateElement(node);");

                // If the node is an expression, then include the type.
                if (IsA(parameterType, typeof(ExpressionSyntax)))
                {
                    builder.AppendLine("        this.AddTypeAttribute(element, node);");
                }

                // Types that have an identifier that contain a name.
                if (IsA(parameterType, typeof(SimpleNameSyntax)))
                {
                    builder.AppendLine("        element.Add(new XAttribute(\"Text\", node.Identifier.Text));");
                }

                // Literals need to have the value
                if (IsA(parameterType, typeof(LiteralExpressionSyntax)))
                {
                    builder.AppendLine("        element.Add(new XAttribute(\"Value\", node.Token.ValueText));");
                }

                // If the node type has a GetDeclaredSymbol method in Microsoft.CodeAnalysis.CSharp.CSharpExtensions
                // then call that and add the information in the symbol to the element.
                if (HasGetDeclaredSymbolMethod(parameterType))
                {
                    builder.AppendLine("        this.AddSymbolInformation(element, this.semanticModel.GetDeclaredSymbol(node));");
                }

                if (IsA(parameterType, typeof(TupleElementSyntax)) || IsA(parameterType, typeof(VariableDeclaratorSyntax))
                    || IsA(parameterType, typeof(ArgumentSyntax)) || IsA(parameterType, typeof(DelegateDeclarationSyntax))
                    || IsA(parameterType, typeof(EventDeclarationSyntax)) || IsA(parameterType, typeof(QueryContinuationSyntax)))
                {
                    //var expressionType = this.semanticModel.GetTypeInfo(node);
                    //element.Add(new XAttribute("Type", TypeName(expressionType.Type)));
                }

                builder.AppendLine("        this.AddLocationAttributes(element, node);");
                builder.AppendLine("        this.stack.Peek().Add(element);");
                builder.AppendLine("        this.stack.Push(element);");
                builder.AppendLine("        base." + visitMethod.Name + "(node);");
                builder.AppendLine("        this.stack.Pop();");
                builder.AppendLine("    }");
            }

            builder.AppendLine("}");
            builder.AppendLine("}");

            var path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments), "Generated.cs");
            WriteToFile(builder, path);
        }
    }
}
